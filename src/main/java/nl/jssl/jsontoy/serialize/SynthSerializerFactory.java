package nl.jssl.jsontoy.serialize;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtField;
import javassist.CtMethod;
import javassist.CtNewMethod;
import javassist.Modifier;
import javassist.NotFoundException;

class SynthSerializerFactory {
    private static final String STRING = "java.lang.String";
    private static final String BOOLEAN = "java.lang.Boolean";
    private static final String CHARACTER = "java.lang.Character";
    private static final String BYTE = "java.lang.Byte";
    private static final String DOUBLE = "java.lang.Double";
    private static final String FLOAT = "java.lang.Float";
    private static final String LONG = "java.lang.Long";
    private static final String SHORT = "java.lang.Short";
    private static final String INTEGER = "java.lang.Integer";

    private final static Set<String> wrappersAndString = new HashSet<>(Arrays.asList(BOOLEAN, CHARACTER, BYTE, DOUBLE, FLOAT, LONG, SHORT, INTEGER,
            STRING));

    private static final String COLLECTION = "java.util.Collection";
    private static final String LIST = "java.util.List";
    private static final String SET = "java.util.Set";
    private static final String MAP = "java.util.Map";

    private static final Map<Class<?>, JSONSerializer<?>> serializers = new HashMap<>();
    private static final String ROOT_PACKAGE = "serializer.";

    private final ClassPool pool = ClassPool.getDefault();
    private CtClass serializerBase;


    public SynthSerializerFactory() {
        init();
    }

    void init() {
        try {
            serializerBase = pool.get(JSONSerializer.class.getName());
        } catch (NotFoundException e) {
            throw new SerializerCreationException(e);
        }
    }

    @SuppressWarnings("unchecked")
    <T> JSONSerializer<T> createSerializer(Class<T> beanjavaClass) {
        if (serializers.containsKey(beanjavaClass)) {
            return (JSONSerializer<T>) serializers.get(beanjavaClass);
        }
        try {
            CtClass beanClass = pool.get(beanjavaClass.getName());
            return tryCreateSerializer(beanjavaClass, beanClass);
        } catch (NotFoundException | CannotCompileException | InstantiationException | IllegalAccessException |
                 InvocationTargetException | NoSuchMethodException e) {
            throw new SerializerCreationException(e);
        }
    }

    private <T> JSONSerializer<T> tryCreateSerializer(Class<?> javaClass, CtClass beanClass) throws NotFoundException, CannotCompileException, InstantiationException,
            IllegalAccessException, InvocationTargetException, NoSuchMethodException {
        CtClass serializerClass = pool.makeClass(createSerializerName(beanClass), serializerBase);

        addToJsonStringMethod(beanClass, serializerClass);

        JSONSerializer<T> jsonSerializer = createSerializerInstance(serializerClass);

        serializers.put(javaClass, jsonSerializer);
        return jsonSerializer;
    }

    /*
     * create method source, compile it and add it to the class under construction
     */
    private void addToJsonStringMethod(CtClass beanClass, CtClass serializerClass) throws NotFoundException, CannotCompileException {
        serializerClass.addMethod(CtNewMethod.make(createToJSONStringMethodSource(beanClass), serializerClass));
    }

    /*
     * Creates the source, handling the for JSON different types of classes
     */
    private String createToJSONStringMethodSource(CtClass beanClass) throws NotFoundException {
        String source = "public String handle(Object object){\n";
        if (beanClass.isArray()) {
            source += "\tObject[] array=(Object[])object;\n";
            source += handleArray();
        } else if (isCollection(beanClass)) {
            source += "\tObject[] array=((java.util.Collection)object).toArray();\n";
            source += handleArray();
        } else if (isMap(beanClass)) {
            source += handleMap();
        } else if (!isPrimitiveOrWrapperOrString(beanClass)) {
            List<CtMethod> getters = getGetters(beanClass);
            if (shouldAddGetterCallers(getters)) {
                source = addGetterCallers(beanClass, source, getters);
            }
        } else {
            source += "\treturn \"\";}";
        }
        return source;
    }

    /*
     * Any Collection is converted to an array, after which code is generated to handle the single elements.
     *
     * A subserializer is created for every single element, but most of the time it will be the same cached instance.
     *
     * The generated code fills a StringBuilder. The values are generated by the subserializers
     */
    private String handleArray() {
        String source = "\tStringBuilder result=new StringBuilder(\"[\");\n";
        source += "\tfor (int i=0; i<array.length; i++){\n";
        source += "\t\tresult.append(" + Serializer.class.getName() + ".toJSONString(array[i]));\n";
        source += "\t\tresult.append(\", \");\n";
        source += "\t};\n";
        source += "\tresult.setLength(result.length()-2);\n";
        source += "\tresult.append(\"]\");\n";
        source += "\treturn result.toString();\n";
        source += "}";
        return source;
    }

    private String handleMap() {
        String source = "StringBuilder result=new StringBuilder(\"{\");\n";
        source += "\tfor (java.util.Iterator entries=((java.util.Map)object).entrySet().iterator();entries.hasNext();){\n";
        source += "\t\tjava.util.Map.Entry entry=(java.util.Map.Entry)entries.next();\n";
        source += "\t\tresult.append(\"\\\"\"+entry.getKey().toString()+\"\\\"\");\n";
        source += "\t\tresult.append(\": \");\n";
        source += "\t\tresult.append(" + Serializer.class.getName() + ".toJSONString(entry.getValue()));\n";
        source += "\t\tresult.append(\", \");\n";
        source += "\t};\n";
        source += "\tresult.setLength(result.length()-2);\n";
        source += "\tresult.append(\"}\");\n";
        source += "\treturn result.toString();\n";
        source += "}";
        return source;
    }

    /*
     * If the class contains fields for which public getters are available, then these will be called in the generated code.
     */
    private String addGetterCallers(CtClass beanClass, String source, List<CtMethod> getters) {
        int index = 0;
        source += "\treturn ";
        source += "\"{";
        for (CtMethod getter : getters) {
            source = addPair(beanClass, source, getter);
            if (index++ < getters.size() - 1) {
                source += ",";
            }
        }
        source += "}\";\n}";
        return source;
    }

    @SuppressWarnings("unchecked")
    private <T> JSONSerializer<T> createSerializerInstance(CtClass serializerClass) throws InstantiationException, IllegalAccessException,
            CannotCompileException, NoSuchMethodException, InvocationTargetException {
        return (JSONSerializer<T>) serializerClass.toClass().getConstructor().newInstance();
    }

    /*
     * custom root package is prepended to avoid the java.lang class in which it's illegal to create new classes
     *
     * Array marks ( '[]' ) are replaced by the 'Array', Otherwise the SerializerClassName would be syntactically incorrect
     */
    public String createSerializerName(CtClass beanClass) {
        return createSerializerName(beanClass.getName());
    }

    public String createSerializerName(String name) {
        return ROOT_PACKAGE + name.replaceAll("\\[]", "Array") + "Serializer";
    }

    private boolean isCollection(CtClass beanClass) throws NotFoundException {
        List<CtClass> interfaces = new ArrayList<>(Arrays.asList(beanClass.getInterfaces()));
        interfaces.add(beanClass);
        for (CtClass interfaze : interfaces) {
            if (interfaze.getName().equals(COLLECTION) || interfaze.getName().equals(LIST) || interfaze.getName().equals(SET)) {
                return true;
            }
        }
        return false;
    }

    private boolean isMap(CtClass beanClass) throws NotFoundException {
        List<CtClass> interfaces = new ArrayList<>(Arrays.asList(beanClass.getInterfaces()));
        interfaces.add(beanClass);
        for (CtClass interfaze : interfaces) {
            if (interfaze.getName().equals(MAP)) {
                return true;
            }
        }
        return false;
    }

    /*
     * The JSON vernacular for key:value is pair...
     */
    private String addPair(CtClass classToSerialize, String source, CtMethod getter) {
        source += jsonKey(getter);
        source += ": "; // what is the rule when it comes to spaces in json?
        source += jsonValue(classToSerialize, getter);
        return source;
    }

    /*
     * derive property key from getter
     */
    private String jsonKey(CtMethod getter) {
        return "\\\"" + toFieldName(getter.getName()) + "\\\"";
    }

    private String jsonValue(CtClass classToSerialize, CtMethod getter) {
        /* primitives are wrapped so the produced methods adhere to the JSONSerializer interface */
        return createSubSerializerForReturnTypeAndAddInvocationToSource(classToSerialize, getter);
    }

    private String createSubSerializerForReturnTypeAndAddInvocationToSource(CtClass classToSerialize, CtMethod getter) {
        /* NB there does not seem to be auto(un))boxing nor generic types (or other jdk1.5 stuff) in javassist compileable code */
        String source = "\"+" + Serializer.class.getName() + ".toJSONString(";

        // cast because of lack of generics
        source += "(" + cast(regularClassname(classToSerialize.getName())) + "object)." + getter.getName() + "()";

        source += ")+\"";
        return source;
    }

    /*
     * turns for example 'getValue' into 'value'
     */
    private String toFieldName(String name) {
        return name.substring(3, 4).toLowerCase() + (name.length() > 4 ? name.substring(4) : "");
    }

    public String regularClassname(String name) {
        return name.replaceAll("\\$", ".");
    }

    private String cast(String classToSerialize) {
        return "(" + classToSerialize + ")";
    }

    /*
     * Retrieves getter methods from a class
     */
    private List<CtMethod> getGetters(CtClass beanClass) {
        List<CtMethod> methods = new ArrayList<>();
        List<CtField> fields = getAllFields(beanClass);
        for (CtField field : fields) {
            try {
                CtMethod method = beanClass.getMethod(getGetterMethod(field), getDescription(field));
                if (Modifier.isPublic(method.getModifiers())) {
                    methods.add(method);
                }
            } catch (NotFoundException n) {
                // ignore
            }
        }
        return methods;
    }

    private String getGetterMethod(CtField field) {
        return "get" + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1);
    }

    private List<CtField> getAllFields(CtClass beanClass) {
        try {
            List<CtField> allfields = new ArrayList<>(Arrays.asList(beanClass.getDeclaredFields()));
            if (beanClass.getSuperclass() != null) {
                return getAllFields(beanClass.getSuperclass(), allfields);
            }
            return allfields;
        } catch (NotFoundException e) {
            throw new SerializerCreationException(e);
        }

    }

    private List<CtField> getAllFields(CtClass beanClass, List<CtField> allfields) {
        allfields.addAll(Arrays.asList(beanClass.getDeclaredFields()));

        return allfields;
    }

    /*
     * is getter list is not empty then callers should be added
     */
    boolean shouldAddGetterCallers(List<CtMethod> getters) {
        return !getters.isEmpty();
    }

    String getDescription(CtField field) throws NotFoundException {
        if (field.getType().isArray()) {
            return "()[" + innerClassName(field.getType().getName()) + ";";
        } else if (!field.getType().isPrimitive()) {
            return "()" + innerClassName(field.getType().getName()) + ";";
        } else {

            return "()" + asPrimitive(field.getType().getName());
        }
    }

    String asPrimitive(String name) {
        switch (name) {
            case "int":
                return "I";
            case "byte":
                return "B";
            case "float":
                return "F";
            case "long":
                return "J";
            case "boolean":
                return "Z";
            case "char":
                return "C";
            case "double":
                return "D";
            case "short":
                return "S";
        }
        return "";
    }

    String innerClassName(String name) {
        return "L" + name.replaceAll("\\.", "/").replaceAll("\\[]", "");
    }

    static boolean isPrimitiveOrWrapperOrString(CtClass beanClass) {
        return beanClass.isPrimitive() || wrappersAndString.contains(beanClass.getName());
    }
}
